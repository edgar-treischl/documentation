[
["index.html", "Mastering Shiny Welcome About the author License", " Mastering Shiny Joe Cheng Welcome This is the online version of Mastering Shiny, a book currently under early development and intended for a late 2020 release by O’Reilly Media. Shiny is a framework for creating web applications using R code. It is designed primarily with data scientists in mind, and to that end, you can create pretty complicated Shiny apps with no knowledge of HTML, CSS, or JavaScript. On the other hand, Shiny doesn’t limit you to creating trivial or prefabricated apps: its user interface components can be easily customized or extended, and its server uses reactive programming to let you create any type of backend logic you want. Shiny is designed to feel almost magically easy when you’re getting started, and yet the deeper you get into how it works, the more you realize it’s built out of general building blocks that have strong software engineering principles behind them. Today, Shiny is used in almost as many niches and industries as R itself is. It’s used in academia as a teaching tool for statistical concepts, a way to get undergrads excited about learning to write code, a splashy medium for showing off novel statistical methods or models. It’s used by big pharma companies to speed collaboration between scientists and analysts during drug development. It’s used by Silicon Valley tech companies to set up realtime metrics dashboards that incorporate advanced analytics. This book complements Shiny’s online documentation and is intended to help app authors develop a deeper understanding of Shiny. After reading this book, you’ll be able to write apps that have more customized UI, more maintainable code, and better performance and scalability. About the author Joe Cheng is the principal developer of Shiny and several of its supporting packages (htmltools, httpuv, later, and promises), and now leads the team responsible for Shiny and Shiny Server. He is the CTO of RStudio, which he joined in 2009. License This book is licensed to you under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0). The code samples in this book are licensed under Creative Commons CC0 1.0 Universal (CC0 1.0), i.e. public domain. "],
["before-we-begin.html", "Chapter 1 Before we begin 1.1 Prerequisites 1.2 Cheat sheet 1.3 If you get stuck", " Chapter 1 Before we begin If you’ve never used Shiny before, welcome! This chapter will help you install all the software you’ll need to follow along with the book. 1.1 Prerequisites The first thing you’ll need to do is install the software you’ll need, if you don’t have it already: R If you don’t have R installed already, you may be reading the wrong book; you need to be proficient with R if you want to write Shiny apps. R for Data Science is a great book for getting started with R. You can download and install R by going to https://www.r-project.org and selecting one of the CRAN mirrors. RStudio RStudio is a free and open source integrated development environment (IDE) for R: a single program that includes a code editor, R console, graphics device, and many features for working productively with R. While you can write and use Shiny apps with any R environment (including R GUI and ESS), RStudio has some nice features specifically for authoring and debugging Shiny apps. We recommend giving it a try, but it’s not required to be successful with Shiny or with this book. You can download RStudio Desktop at: https://www.rstudio.com/products/rstudio/download/ Shiny Shiny is just an R package; you install it the same way you install any R package. From the R console: install.packages(&quot;shiny&quot;) Other R packages This book is heavy on code, and we will often use other R packages in our examples. You can install them all now by running this code: install.packages(c(&quot;magrittr&quot;, &quot;lubridate&quot;, &quot;readr&quot;, &quot;dplyr&quot;, &quot;ggplot2&quot;, &quot;gt&quot;)) TODO: Update this list before final draft; see DESCRIPTION for the definitive list. 1.2 Cheat sheet You may find it helpful to print a copy of our Shiny “cheat sheet”, a reference card for many of the most important concepts and functions in Shiny. It won’t all make sense to you yet, but as you work through the chapters you’ll find it more and more helpful to refresh your memory. https://www.rstudio.com/resources/cheatsheets/ 1.3 If you get stuck Got a problem you can’t figure out, or a question this book (and Google) can’t answer? You can find help at our community site: https://community.rstudio.com/c/shiny. "],
["your-first-shiny-app.html", "Chapter 2 Your first Shiny app 2.1 Introduction 2.2 Create app dir and file 2.3 Running and stopping 2.4 Adding UI controls 2.5 Adding behavior 2.6 Reducing duplication with reactive expressions 2.7 Exercises", " Chapter 2 Your first Shiny app 2.1 Introduction In this chapter, we’ll create a simple Shiny app. Along the way, you’ll learn the basic structure of a Shiny app, and how to save and run Shiny apps using the RStudio IDE. You’ll also take your first steps into reactive programming. We’ll start by showing you the minimum boilerplate needed to get a Shiny app running, then you’ll learn how to run it, and how to stop it when you’re done. Next you’ll learn the two key components of every shiny app: the UI (short for user interface) which defines how your app looks, and the server function which defines how you app works. Shiny uses reactive programming to automatically update app outputs when the inputs change; we’ll finish off the chapter by learning the third important reactive component: reactive expressions. library(shiny) 2.2 Create app dir and file There are several ways to create a Shiny app. The simplest is to create a new directory for your app, and put a single file called app.R in it. This app.R file will be used to tell Shiny both how your app should look, and how it should behave. (Tip: In RStudio IDE, you can easily create a new directory and app.R file in one step using File | New File | Shiny Web App.) Open up the app.R file and make its contents look like this: library(shiny) ui &lt;- &quot;Hello, world!&quot; server &lt;- function(input, output, session) { } shinyApp(ui, server) This is a complete, if trivial, Shiny app. Looking closely at the code above, our app.R does four things: Calls library(shiny) to load the shiny package. Defines the user interface (or UI for short) for our app. In this case, it’s nothing but the words “Hello, world!”. Specifies the behavior of our app by defining a server function. It’s currently empty, but we’ll be back to revisit this shortly. Runs shinyApp(ui, server) to construct a Shiny application object from the UI object and server function. 2.3 Running and stopping Run this Shiny app in RStudio1 now by pressing Ctrl+Shift+Enter, or by clicking the Run App button in the document toolbar. You should see a web application launch in a new window, with only the words “Hello, world!”: This is RStudio’s Shiny app window. From here, you can click “Open in Browser” to view the app in your system default web browser, which can be helpful for testing or debugging. If you prefer to always launch straight into your system default web browser, or RStudio’s Viewer pane, you can use the Run App button’s dropdown menu to choose one of those instead: Before you close the app, go back to your main RStudio window and look at the R console. You’ll notice that the console says something like: #&gt; Listening on http://127.0.0.1:3827 This is telling you the URL where your app can be found: 127.0.0.1 is a standard address that means “this computer” and 3827 is randomly assigned port number. You can enter that URL into any compatible2 web browser to open another copy of your app. The second thing to notice is that R is busy: the R prompt isn’t visible, and the console toolbar displays a stop sign icon. While a Shiny app is running, it “blocks” the R console. This means that you can’t run new commands at the R console until after the Shiny app either stops of its own accord, or (much more commonly) is interrupted. Go ahead and stop your app using any one of these options: Click the stop sign icon on the R console toolbar. Press the Esc key (Note: the keyboard focus must be in either the RStudio console or editor). Close the Shiny app window. Non-RStudio users: However you normally interrupt running R code, e.g. Ctrl+C or Esc. 2.4 Adding UI controls Next, we’ll add some inputs and outputs to our UI so it’s not quite so minimal. Change your ui object to look like this: ui &lt;- fluidPage( selectInput(&quot;dataset&quot;, label = &quot;Dataset&quot;, choices = ls(&quot;package:datasets&quot;) ), verbatimTextOutput(&quot;summary&quot;), tableOutput(&quot;table&quot;) ) This example uses four functions we haven’t seen before. fluidPage() is one of several layout functions which set up the basic visual structure of the page. You’ll learn more about them in Section 3.4 selectInput() is an input control, which lets the user interact with the app by providing a value. In this case, it’s a fancy select box with the title “Dataset” and lets you choose one of the built-in datasets that come with R. You’ll learn more about inputs in Section 3.2. verbatimTextOutput() and tableOutput() are output controls, that tell Shiny where to put rendered output (we’ll get into the how in a moment). verbatimTextOutput() displays code and tableOutput displays tables. You’ll learn more about outputs in Section 3.3. Layout functions, inputs, and outputs are used for different purposes, but they fundamentally the same under the covers: they’re all just fancy ways to generate HTML, and if you call any of them outside of a shiny app, you’ll see HTML printed out at the console. Don’t be afraid to poke around to see how these various layouts and controls work under the hood. You’ll learn more of the details in Chapter 5. Go ahead and run the app again. You’ll now see a select box with a set of names, and very little else. We’ve defined the UI, but haven’t yet told Shiny what data to put in the outputs. 2.5 Adding behavior Next, we’ll bring the outputs to life by defining them in the server function. Shiny uses a reactive programming framework to make apps interactive. You’ll learn more about reactive programming in Chapter 4, but for now, just be aware that it often involves telling Shiny how to perform a computation, not ordering Shiny to actually go do it. It’s like the difference between giving someone a recipe instead of demanding that they go make you a sandwich. In this simple case, we’re going to tell Shiny how to fill in the summary and table outputs—we’re providing the “recipes” for those outputs. Replace your empty server function with this: server &lt;- function(input, output, session) { output$summary &lt;- renderPrint({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;, inherits = FALSE) summary(dataset) }) output$table &lt;- renderTable({ dataset &lt;- get(input$dataset, &quot;package:datasets&quot;, inherits = FALSE) dataset }) } Almost every output you’ll write in Shiny will follow this same pattern: output$IDENTIFIER &lt;- renderTYPE({ # Expression that generates whatever kind of output # renderTYPE expects }) The left-hand side of the assignment operator (&lt;-), output$IDENTIFIER, indicates that you’re providing the recipe for the Shiny output with the matching ID. The right-hand side of the assignment specifies uses a specific render function to wrap a code block that you provide; in the example above, we use renderPrint and renderTable wrap our app-specific logic. Each renderXXX function is designed to work with a particular type of output that’s passed to an xxxOutput function. In this case, we’re using renderPrint() to capture and display the outut from summary() output, and renderTable() to display the actual data frame in a table. Run the app again and play around, watching what happens to the output when you change an input. Outputs are reactive which means that Shiny automatically knows when to recalculate them. Because both of the rendering code blocks we wrote read input$dataset, whenever the value of input$dataset changes (i.e. the user changes their selection in the UI), both outputs will recalculate and update in the browser. Shiny takes care of this detail so that you don’t need to worry about it. 2.6 Reducing duplication with reactive expressions Even in this simple example, we have some code that’s duplicated: the line dataset &lt;- get(input$dataset, &quot;package:datasets&quot;, inherits = FALSE) is present in both outputs. In every kind of programming, it’s poor practice to have duplicated code; it can be computationally wasteful, and more importantly, it increases the difficulty of maintaining or debugging the code. In traditional R scripting, we use two techniques to deal with duplicated code: either we capture the value using a variable (if we only need to do the calculation once), or capture the computation itself using a function (if we need to perform the calculation multiple times, possibly based on different inputs). Unfortunately neither of these approaches work here (for resaons you’ll learn about in Section 4.3.3), and we need new mechnaism: reactive expressions, created by wrapping a block of code with reactive({...}). You assign the reactive expression object to a variable, and call the variable like a function to retrieve its value. # Much better server &lt;- function(input, output, session) { dataset &lt;- reactive({ get(input$dataset, &quot;package:datasets&quot;, inherits = FALSE) }) output$summary &lt;- renderPrint({ summary(dataset()) }) output$table &lt;- renderTable({ dataset() }) } While it looks like you’re calling a function, a reactive expression has an important difference: it only runs its code the first time it is called (e.g. from renderPrint() and renderTable()), then caches the resulting value until it needs to be updated (for example, if input$dataset changed). Once that happens, the next time it’s called, it will execute its code again, and cache the resulting value, and so on. We’ll come back to reactive programming multiple times, but even armed with a cursory knowledge of inputs, outputs, and reactive expressions, it’s possible to build quite useful Shiny apps! 2.7 Exercises TODO If you’re not using RStudio, you can use setwd() to change the current working directory to the app dir, and call shiny::runApp() (or alternatively, don’t change the current working directory and pass the path to the app dir to runApp() as an argument).↩ Notably, Internet Explorer versions earlier than IE11 are not compatible when running Shiny directly from your R session. However, Shiny apps deployed on Shiny Server or ShinyApps.io can work with IE10 (earlier versions of IE are no longer supported).↩ "],
["basic-ui.html", "Chapter 3 Basic UI 3.1 Introduction 3.2 Inputs 3.3 Outputs 3.4 Layouts 3.5 Common styles", " Chapter 3 Basic UI 3.1 Introduction Now that you’ve got a basic app under your belt, we’re going to explore the details that make it tick. As you saw in the previous chapter, Shiny encourages separation of the code that generates your user interface (ui) from the code that drives your app’s behavior (server). In this chapter, we’ll dive deeper into the UI side of things. This chapter will focus on the most important functions provides for input, output, and layout. Combining what you learned in the last chapter with what you learn here will allow you to create a wide range of simple apps, where the connections between the inputs and outputs are straightforward. library(shiny) 3.2 Inputs As we saw in the previous chapter, you use functions like sliderInput(), selectInput(), textInput(), and numericInput() to insert input controls into your UI. Now we’ll discuss the common structure that underlies all input functions then give a quick overview of the most important input functions. 3.2.1 Common structure All input functions have the same first argument: inputId. This is a unique identifer that you’ll use in your server function to refer to the current value. The inputId should: Be a simple string that contains only letters, numbers, and underscores (no spaces, dashes, periods, or other special characters allowed!). Be unique. If it’s not unique, you’ll have no way to refer to this control in your server function! Most input functions have a second parameter called label. This is used to create create a human-readable label for the control. Shiny doesn’t place any restrictions on this string, but you’ll need to carefully think about it in order to back your app usable by humans. The third parameter is typically value, which lets you set the default value. When creating an input function, you should refer to the inputId and label by position, and name all the remaning arguments: sliderInput(&quot;min&quot;, &quot;Limit (minimum)&quot;, value = 50, min = 0, max = 100) Next, we’ll give a quick overview of the most important controls. The goal is to give you a rapid overview of your options, not to exhaustively describe all the arguments. Refer to the documentation for more details. There are two types of controls we’ll come back to in later chapters: we’ll cover fileInput() when we discuss uploading and downloading files in Chaper XYZ, and we’ll cover actionButton() when we discuss buttons and initiating “actions” in Chapter XYZ. 3.2.2 Free text To collect small amounts of text use textInput(); for passwords use passwordInput(); for larger amounts of text, use textAreaInput(). ui &lt;- fluidPage( textInput(&quot;name&quot;, &quot;What&#39;s your name?&quot;), passwordInput(&quot;password&quot;, &quot;What&#39;s your password?&quot;), textAreaInput(&quot;story&quot;, &quot;Tell me about yourself&quot;, rows = 3, cols = 80) ) If you want to ensure that the text has certain properties you can use validate(), which we’ll come back to in Chapter XYZ. 3.2.3 Numeric inputs To collect numeric values, you can create a slider with sliderInput(), or a constraind textbox with numericInput(). If you supply a length-2 numeric vector for the default value of sliderInput(), you get a “range” slider that has two ends. ui &lt;- fluidPage( numericInput(&quot;num&quot;, &quot;Number one&quot;, value = 0, min = 0, max = 100), sliderInput(&quot;num2&quot;, &quot;Number two&quot;, value = 50, min = 0, max = 100), sliderInput(&quot;rng&quot;, &quot;Range&quot;, value = c(10, 20), min = 0, max = 100) ) Generally, only use sliders if there’s a relatively small ranges of values, and the precise value is not so important. Attempting to precisely select a number on a slider is an exercise in frustration! 3.2.4 Dates Dates have two controls that provide a helpful calendar picker, and ensure that the user picks a valid date. ui &lt;- fluidPage( dateInput(&quot;dob&quot;, &quot;When were you born?&quot;), dateRangeInput(&quot;holdiay&quot;, &quot;When do you want to go on vacation next?&quot;) ) You’ll typically also want to consider setting format, language, and weekstart to make sure that the dates appear in a natural way to your users. 3.2.5 Limited choices If you want the user to choose from a prespecified set of options, there are two main options: selectInput() and radioButtons(). animals &lt;- c(&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;, &quot;bird&quot;, &quot;other&quot;, &quot;I hate animals&quot;) ui &lt;- fluidPage( selectInput(&quot;state&quot;, &quot;What&#39;s your favourite state?&quot;, state.name), radioButtons(&quot;animal&quot;, &quot;What&#39;s your favourite animal?&quot;, animals) ) Radio buttons have two advantages. Firstly, they show all possible options, making them most suitable for short lists. Through the choiceNames/choiceValues parameters they can be arbitrary HTML: ui &lt;- fluidPage( radioButtons(&quot;rb&quot;, &quot;Choose one:&quot;, choiceNames = list( icon(&quot;angry&quot;), icon(&quot;smile&quot;), icon(&quot;sad-tear&quot;) ), choiceValues = list(&quot;angry&quot;, &quot;happy&quot;, &quot;sad&quot;) ) ) The primary advantage of selectInput() is that it doesn’t show all options at once, making it more suitable for longer options. You can also set multiple = TRUE to allow multiple selections ui &lt;- fluidPage( selectInput( &quot;state&quot;, &quot;What&#39;s your favourite state?&quot;, state.name, multiple = TRUE ) ) The equivalent to a multi-select radioButtons() is checkboxInputGroup(): ui &lt;- fluidPage( checkboxGroupInput(&quot;animal&quot;, &quot;What animals do you like?&quot;, animals) ) 3.2.6 Yes/no questions To retrieve the answer to a single yes/no question, use checkboxInput(): ui &lt;- fluidPage( checkboxInput(&quot;cleanup&quot;, &quot;Clean up?&quot;) ) 3.3 Outputs Output functions are used to tell Shiny where and how to place outputs that are defined in the app’s server. Like inputs, outputs take a unique ID as their first argument, and are paired with server code. Outputs generally start out as empty rectangles and need to be fed data from the server in order to actually appear. Outputs have few arguments because, by and large, they just create recepticles for output. We’ll show you the main output functions below, along with the render functions that they’re usually coupled with. 3.3.1 Text Output regular text with textOutput(), and code with verbatimTextOutput(). On the server side they are coupled with renderText() which displays text returned by the code and renderPrint() which displays any text printed by the code. ui &lt;- fluidPage( textOutput(&quot;text&quot;), verbatimTextOutput(&quot;code&quot;) ) server &lt;- function(input, output, session) { output$text &lt;- renderText(&quot;Hello friend!&quot;) output$code &lt;- renderPrint(summary(1:10)) } 3.3.2 Tables Two options built in to shiny. tableOutput() and renderTable() render a static table of data. All the data is shown. dataTableOutput() and renderDataTable() render a dynamic table, suitable for any size of dataset. The data is dynamically sent from the server as needed. ui &lt;- fluidPage( tableOutput(&quot;static&quot;), dataTableOutput(&quot;dynamic&quot;) ) server &lt;- function(input, output, session) { output$static &lt;- renderTable(head(mtcars)) output$dynamic &lt;- renderDataTable(mtcars, options = list(pageLength = 5)) } 3.3.3 Plots Display R graphics (base and ggplot2) with plotOutput() and renderPlot(): ui &lt;- fluidPage( plotOutput(&quot;plot&quot;, width = &quot;400px&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot(plot(1:5)) } plotOutput() has a number of arguments like click, dblclick, and hover. If you pass these a string, click = &quot;plot_click&quot;, they’ll create a reactive output that you can use to handle user events. More on that in Chapter XYZ. 3.4 Layouts Shiny includes several classes of UI functions that are used to layout inputs and outputs within the app. This chapter focuses on the built-in components centered around fluidPage() and fixedPage() as these provide the structure seen in the most common style of shiny apps. In future chapters you’ll learn about other layout families like dashboards and dialog boxes. Layouts are composed hierarchically. When you see code like this: fluidPage( titlePanel(&quot;Hello Shiny!&quot;), sidebarLayout( sidebarPanel( sliderInput(&quot;obs&quot;, &quot;Observations:&quot;, min = 0, max = 1000, value = 500) ), mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) First skim it by focusing on the hierarchy of the function calls: fluidPage( titlePanel(), sidebarLayout( sidebarPanel( sliderInput(&quot;obs&quot;) ), mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) Even without knowing anying about the layout functions you can read the function names to guess what this app is going to look like. You can imagine that this is going to generate a classic website design: a title bar at top, followed by a sidebar (containing a slider) and a main panel containing a plot. 3.4.1 Page functions The first layout function you’ll encounter in the UI is a page function. Page functions don’t do anything by themselves, but set up the HTML, CSS, and JS that the page needs. The most common page function is fluidPage(): fluidPage(..., title = NULL, theme = NULL) fluidPage() sets up your page to use the Bootstrap CSS framework, https://getbootstrap.com. Bootstrap provides your web page with attractive settings for typography and spacing, and also preloads dozens of CSS rules that can be invoked to visually organize and enhance specific areas of your UI. We’ll take advantage of quite a few of these Bootstrap rules as we proceed through this chapter. The “fluid” in fluidPage means the page’s content may resize its width (but not height) as the size of the browser window changes. The other option is fixedPage(), which means the page contents will never exceed 960 pixels in width. Technically, this is all you need: you can put inputs and outputs directly inside fluidPage(): fluidPage( sliderInput(&quot;min&quot;, &quot;Limit (minimum)&quot;, min = 0, max = 100, value = 50), plotOutput(&quot;distPlot&quot;) ) This is fine for very simple examples, but if you want your app to look good, you’ll need to use more layout functions to define the basic structure of the app. Here I’ll introduce you to two common structures: a page with sidebars, and a multirow app. 3.4.2 Themes https://shiny.rstudio.com/gallery/shiny-theme-selector.html 3.4.3 Under the hood All web pages are constructed out of HTML, and Shiny user interfaces are no different—although they are generally expressed using R, their ultimate job is to produce HTML. As a Shiny app author, you can use high-level layout functions in R that keep you far away from the details of HTML. You can also work with HTML tags directly to achieve any level of customization you want. These approaches are by no means exclusive; you can mix high-level functions with low-level HTML as much as you like. while Chapter 5 will delve into using lower-level features for authoring HTML directly. They’re just functions that return HTML. fluidPage() &lt;div class=\"container-fluid\"&gt;&lt;/div&gt; So if you notice a common pattern in your apps you can easily construct your own function. Producing with inputs and outputs is a little trickier in a function because of the need for unique IDs. Fixing this problem is the motivation for Shiny modules, which we’ll come back to in Chapter XYZ. 3.5 Common styles 3.5.1 Page with sidebar A great structure for simple shiny apps is a two-column layout where the interactive controls appear in a sidebar on the left, and the results appear in the right. This is easy to construct with sidebarLayout() and friends. The basic code structure looks like this: fluidPage( headerPanel( # app title/description ), sidebarLayout( sidebarPanel( # inputs ), mainPanel( # outputs ) ) ) And generates an app with this basic structure: 3.5.2 Multi-row You’ll need greater flexibilty for more complex apps, and the next step up in complexity in the multirow layout. This is defined by any number of fluidRow() calls, each of which contains one or more column()s. The basic structure looks like this: fluidPage( fluidRow( column(4, ... ), column(8, ... ) ), fluidRow( column(6, ... ), column(6, ... ) ) ) which generates a layout like this: Column widths must add up to 12, but this still gives you substantial flexibility. You can easily create 2-, 3-, or 4- column layouts (more than that starts to get cramped), or sidebars that are narrower or wider than the default in sidebarLayout(). 3.5.3 Dashboard http://rstudio.github.io/shinydashboard/structure.html#layouts "],
["reactivity-intro.html", "Chapter 4 Basic reactivity 4.1 Introduction 4.2 The server function 4.3 Using inputs and outputs together 4.4 Controlling effect flow 4.5 Reactivity roadblocks", " Chapter 4 Basic reactivity 4.1 Introduction In the the last chapter, we talked about creating user interfaces. Now we’ll move on to discuss the server side of Shiny, where you use R code at runtime to make your user interface come to life! In Shiny, you express your server logic using reactive programming. Reactive programming is an elegant and powerful programming paradigm, but it can be disorienting at first because it’s a very different paradigm to writing a script. The key idea of reactive programming is to specify a graph of dependencies so that when an input changes, all outputs are automatically updated. This makes the flow of an app considerably simpler, but it takes a while to get your head around how it all fits together. This chapter will provide a gentle walkthrough of reactive programming, introducing some of the most basic reactive constructs you’ll use in your Shiny apps. We’ll start with a survey of the server function, discussing in more detail how the input and output arguments work. Next we’ll review the simplest form of reactivity (where inputs are directly connected to outputs), and then discuss how reactive expressions allow you to eliminate duplicated work. We’ll finish by reviewing some common roadblocks encountered by newer shiny users. library(shiny) 4.2 The server function The typical Shiny app boilerplate looks like this: library(shiny) ui &lt;- fluidPage( # UI goes here ) server &lt;- function(input, output, session) { # Server logic goes here } shinyApp(ui, server) As you can see, the server function is a function that you (the app author) define, and pass to Shiny via the shinyApp function. You’ll never invoke a server function yourself; rather, Shiny invokes it whenever a new session begins. A session begins each time the Shiny app is loaded by a browser, either by different people, or by the same person opening multiple tabs. Almost of the reactive programming you’ll do in Shiny will be directly in the server function3. The server function is so important because it encapsulates the connection to a single browser session, creating a private scope for that particular session. In other words, every variable you create in the body of the server function is only accessible to a particular session. Most of the time, we’ll also want our reactive interactions to be private to each session too: when user A moves a slider, you usually want outputs to update ony for user A, not user B. Therefore, we’ll write our reactive logic in the server function. You might have wondered it’s safe for two users to connect to a single Shiny app at the same time: how does Shiny keep track of whose inputs and outputs are whose? This happens automatically because shiny calls your server function once for each person, and because each call to an R function is independent, there’s no way for the variables to get muddled up. 4.2.1 Server function parameters Server functions always take three parameters: input, output, and session4. You’ll never create these objects yourself; rather, they are created by Shiny when a session begins. Each combination of input, output, and session connects back to a specific session, and we’ll use these objects to communicate back and forth with the browser. For the moment, we’ll focus on input and output, and leave session for later chapters. 4.2.2 Input The input object is a list-like object that contains all the input data sent from the browser, stored by input ID. If your UI contains a numeric input control with an input ID of count: numericInput(&quot;count&quot;, label = &quot;Number of values&quot;, value = 100) then input$count will initially contain the value 100. As the user changes the value in the browser, input$count will be updated automatically by Shiny. Unlike a typical R list, input objects are read-only. The following line will not work: # Throws an error input$count &lt;- 10 The reason for this restriction is that input is reflects what’s happening in the browser; the browser is the “single source of truth”. Being able to directly modify the input object would introduce a second source of truth, which could then be in conflict with the state of the browser. One more important thing about input is that it’s a bit selective about who is allowed to read it. You must be in a reactive context to be able to access it. We’ll come back to that idea very shortly, but it’s a fundamentally idea that allows outputs to automatically update when an input changes. For example, this server function will throw an error: ui &lt;- fluidPage( numericInput(&quot;count&quot;, label = &quot;Number of values&quot;, value = 100) ) server &lt;- function(input, output, session) { message(&quot;The value of input$count is &quot;, input$count) } shinyApp(ui, server) #&gt; Error: Operation not allowed without an active reactive context. #&gt; (You tried to do something that can only be done from inside #&gt; a reactive expression or observer. To new Shiny app authors, this is an extremely surprising limitation! But rest assured that input’s selectivity is a feature, not a bug. To explain why, we’ll first need to talk about outputs. 4.2.3 Output Shiny UIs not only contain inputs, but also outputs. The various *Output UI functions—plotOutput(), tableOutput(), verbatimTextOutput(), and friends—merely insert empty boxes, or placeholders, into your UI. The output object is how you tell Shiny how to populate these empty boxes. You use the output object by wrapping a code block with a render function, then assigning all of that to a slot on the output object. Like this: server &lt;- function(input, output, session) { output$hist_plot &lt;- renderPlot({ # Choose 100 random values from a normal distribution, # and create a histogram hist(rnorm(100)) }) } This snippet assumes that the UI contains a plotOutput(&quot;hist_plot&quot;). The render function you use (renderPlot) must match with the output function (plotOutput), and the output slot (hist_plot) must match with the output ID. (Note that the ID is quoted in the UI, but not in the server.) 4.2.4 Imperative vs. declarative You might read this code and think it means, “Render the plot hist(rnorm(100L)), and fill plotOutput(&quot;hist_plot&quot;) with it.” But this intuition is wrong, in a subtle but important way. This code does not instruct Shiny to render the plot and send it to the browser, but instead, tells Shiny how it could render the plot, if and when Shiny wanted to. This is the difference between imperative programming, which is what you’re probably used to, and declarative programming, which is what Shiny uses. Imperative programming is about issuing specific commands, to be carried out immediately. Declarative programming is about expressing some higher-level goals or constraints, and relying on someone else (in this case, Shiny) to decide how and/or when to translate that into action. Imperative says: “Go make me a sandwich.” Declarative says: “Ensure there is a sandwich in the refrigerator at all times.” (Sorry, sometimes Declarative can be a demanding jerk.) You may actually be more familiar with declarative programming than you think. SQL and regular expressions are examples of declarative programming. Excel formulas are too. The correct, declarative reading of the code snippet above is “Whenever you want to render the hist output, be sure to do it as a plot, and the logic for doing so is hist(rnorm(100L)).” It’s totally up to Shiny whether and when to actually render the plot; maybe right away, maybe quite a bit later, maybe many times, maybe never. This isn’t to imply that Shiny is capricious and arbitrary, only that it’s Shiny’s responsibility, not yours, to decide when render logic is actually executed. 4.3 Using inputs and outputs together The above rendering logic, hist(rnorm(100)), isn’t very exciting; the user can’t interact with this app in any way (unless you count reloading the browser, which would generate a new batch of values). Let’s modify the output to use the input. The complete app is below: library(shiny) ui &lt;- fluidPage( numericInput(&quot;count&quot;, label = &quot;Number of values&quot;, value = 100), plotOutput(&quot;hist_plot&quot;) ) server &lt;- function(input, output, session) { output$hist_plot &lt;- renderPlot({ # Choose input$count random values from a normal distribution, # and create a histogram hist(rnorm(input$count)) }) } shinyApp(ui, server) Run this app, and you’ll notice that as you change the count input, the output updates immediately. This is reactive programming at work! When one thing (input$count) changes, other things (output$hist_plot) automatically and immediately respond. Let’s see what happens if we add a few more inputs and outputs. In this next example, we’ve added a new input that affects the histogram: input$bins is used to specify the number of bins in the histogram. We’ve also added a table output, that limits itself to displaying the first input$rows of the data. library(shiny) ui &lt;- fluidPage( numericInput(&quot;count&quot;, label = &quot;Number of values&quot;, value = 100), numericInput(&quot;bins&quot;, label = &quot;Bins&quot;, value = 10), plotOutput(&quot;hist_plot&quot;), numericInput(&quot;rows&quot;, label = &quot;Rows to show&quot;, 10), tableOutput(&quot;value_table&quot;) ) server &lt;- function(input, output, session) { output$hist_plot &lt;- renderPlot({ # Choose input$count random values from a normal distribution, # and create a histogram values &lt;- rnorm(input$count) hist(values, breaks = input$bins) }) output$value_table &lt;- renderTable({ # Choose input$count random values from a normal distribution, # and display the first input$rows values &lt;- rnorm(input$count) data.frame(head(values, input$rows)) }, colnames = FALSE) } shinyApp(ui, server) By careful inspection of the code, we can see that input$count affects both outputs, while input$bins affects only the plot and input$rows affects only the table. Run the app, and you’ll see that Shiny knows this too. If you change input$bins, the plot is affected but the table is not. If you change input$rows, the table is affected but the plot is not. As your shiny apps get more complex, you’ll find that carefully drawing out the graph of reactive inputs and outputs helps you to understand what’s going on. The following diagram introduces you to the basic conventions we’ll use throughout this book. The point of this example is to demonstrate that Shiny doesn’t simply re-render all of its outputs whenever an input has changed. Somehow, without a lot of help from us, Shiny figures out which inputs should affect which outputs. This is the most “magical” aspect of reactive programming, and we’ll eventually pull back the curtain; for now, just trust that it works. 4.3.1 Outputs are atomic Shiny is smart enough to discern that an output needs to be updated. However, it’s not nearly smart enough to know if it can get away with running only part of the output’s code block. For example, the code for hist_plot has two lines: values &lt;- rnorm(input$count) hist(values, breaks = input$bins) As a human looking at this code, you might conclude that when input$bins changes, it’s not necessary to re-run both lines; if we still had access to the existing values variable, merely running the second line might be enough. Shiny doesn’t try to be this clever. Instead, an output’s render code block is always executed in its entirety, whether it’s two lines of code or two hundred. In this way, each output represents an indivisible unit. 4.3.2 Side effects 4.3.3 Reactive expressions If you read the code above carefully you might have noticed that we’re actually generating the random numbers in two different places. The table and the histogram are actually displaying the results from two unrelated datasets! To fix that problem we need to introduce one more big idea: the reactive expression. A reactive expression is created using reactive(). It ordinary R code, and makes it reactive so that it automatically updates when it’s inputs change. To use a reactive input, you call it like a function. server &lt;- function(input, output, session) { values &lt;- reactive({ rnorm(input$count) }) output$hist_plot &lt;- renderPlot({ hist(values(), breaks = input$bins) }) output$value_table &lt;- renderTable({ data.frame(head(values(), input$rows)) }) } This leads to the following reactivity diagram. You can see that we’re starting to develop a more complex graph. We’ll come back to exactly how events flow through this graph, and how Shiny ensures that it does the smallest amount of work in Chapter 6. Reactive expressions are extremely important for creating efficient shiny apps because they are only updated when their inputs change. This means that you can use them to encapsulate expensive operations so that they are only re-computed the minimal number of times. If you have every used a tool like make, this might seem familiar. But often in reactive programming, neither of these choices satisfy. Using a variable won’t work: # Don&#39;t do this! server &lt;- function(input, output, session) { dataset &lt;- get(input$dataset, &quot;package:datasets&quot;, inherits = FALSE) output$summary &lt;- renderPrint({ summary(dataset) }) output$table &lt;- renderTable({ dataset }) } In this code, we’re attempting to calculate the value of dataset just once, as the session starts. But the value of input$dataset may change over time. We noted a few paragraphs ago that Shiny outputs are reactive (they re-execute as necessary); the same cannot be said for free-floating code like this. So the result of extracting a variable like this is tha the dataset variable will assume some value at startup based on the initial value of input$dataset, and stay at that value forever. This is clearly not what we want, and is such an easy trap to fall into that in fact Shiny detects this condition and throws an error immediately. If using a variable won’t work, how about a function? This will work, and takes care of the code duplication, but it does result in duplicated effort: # Don&#39;t do this! server &lt;- function(input, output, session) { getDataset &lt;- function() { get(input$dataset, &quot;package:datasets&quot;, inherits = FALSE) } output$summary &lt;- renderPrint({ summary(getDataset()) }) output$table &lt;- renderTable({ getDataset() }) } We get the correct behavior this time, at least—we’re calling getDataset() from within our output code, so Shiny will know to recalculate the outputs when input$dataset changes. However, for each change to input$dataset, getDataset is going to be called twice, and its work is therefore going to be performed twice. (In this example, the work being done in getDataset is totally trivial so it doesn’t actually matter; just imagine we’re doing a more expensive operation like retrieving a dataset from a web service or database, or fitting a model over a large dataset, or performing simulations.) To summarize: while variables calculate the value only once (not often enough), and functions calculate the value every time they’re called (too often), reactive expressions calculate the value only when it might have changed (just right!). 4.4 Controlling effect flow Buttons and observers. 4.5 Reactivity roadblocks The primary exception is where there’s some work that can shared across multiple users. For example, all users might be looking at the same large csv file, so you might as well load it once and share it between users. We’ll come back to that idea in Chapter XYZ.↩ For legacy reasons, session is optional, but you should always include it.↩ "],
["advanced-ui.html", "Chapter 5 Advanced UI 5.1 Introduction 5.2 HTML 101 5.3 Generating HTML with tag objects 5.4 Customizing with CSS 5.5 Managing JavaScript/CSS dependencies", " Chapter 5 Advanced UI 5.1 Introduction The native languages of the web are HTML (for content), CSS (for styling), and JavaScript (for behavior). Shiny is designed to be accessible for R users who aren’t familiar with any of those languages. But if you do speak these languages, you can take full advantage of them with Shiny to customize your apps or extend the Shiny framework. The previous chapter showed you the higher-level UI functions that come with Shiny. In this chapter, we’ll take that a couple of steps deeper by learning how our R code gets translated into the HTML that’s ultimately sent to the browser. Armed with that knowledge, you’ll be able to add arbitrary HTML and CSS to your Shiny apps with ease. If you don’t know HTML, and aren’t keen to learn, you can safely skip this chapter. If you don’t know HTML today but may be inclined to learn it, you should be able to make sense of this chapter and understand the relationship between Shiny UI and HTML. If you are familiar with HTML already, you should find this chapter extremely useful–and you can skip over the sections that introduce HTML and CSS. Outline Section 5.2 is a quick but gentle guide to the basics of HTML. It won’t turn you into a web designer, but you’ll at least be able to understand the rest of the chapter. Section 5.3 introduces tag objects, and the family of functions that produce them. These functions give us all the flexibility of writing raw HTML, while still retaining the power and syntax of R. Section 5.4 demonstrates several ways of incorporating custom CSS into your app (for example, to customize fonts and colors). Section 5.5 introduces HTML dependency objects, which can be used to tell Shiny about JavaScript/CSS dependency files that should be used. 5.2 HTML 101 To understand how UI functions in R work, let’s first talk about HTML, in case you’re not familiar with it (or its cousin, XML). If you’ve worked with HTML before, feel free to skip to Section 5.3. HTML is a markup language for describing web pages. A markup language is just a document format that contains plain text content, plus embedded instructions for annotating, or “marking up”, specific sections of that content. These instructions can control the appearance, layout, and behavior of the text they mark up, and also provide structure to the document. Here’s a simple snippet of HTML: This time I &lt;em&gt;really&lt;/em&gt; mean it! The &lt;em&gt; and &lt;/em&gt; markup instructions indicate that the word really should be displayed with special emphasis (italics): This time I really mean it! &lt;em&gt; is an example of a start tag, and &lt;/em&gt; (note the slash character) is an example of an end tag. 5.2.1 Inline formatting tags em is just one of many HTML tags that are used to format text: &lt;strong&gt;...&lt;/strong&gt; makes text bold &lt;u&gt;...&lt;/u&gt; makes text underlined &lt;s&gt;...&lt;/s&gt; makes text strikeout &lt;code&gt;...&lt;/code&gt; makes text monospaced 5.2.2 Block tags Another class of tags is used to wrap entire blocks of text. You can use &lt;p&gt;...&lt;/p&gt; to break text into distinct paragraphs, or &lt;h3&gt;...&lt;/h3&gt; to turn a line into a subheading. .sourceCode.html { white-space: pre-wrap !important; } &lt;h3&gt;Chapter I. Down the Rabbit-Hole&lt;/h3&gt; &lt;p&gt;Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it, ‘and what is the use of a book,’ thought Alice ‘without pictures or conversations?’&lt;/p&gt; &lt;p&gt;So she was considering in her own mind (as well as she could, for the hot day made her feel very sleepy and stupid), whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her.&lt;/p&gt; When rendered, this HTML looks like: Chapter I. Down the Rabbit-Hole Alice was beginning to get very tired of sitting by her sister on the bank, and of having nothing to do: once or twice she had peeped into the book her sister was reading, but it had no pictures or conversations in it, ‘and what is the use of a book,’ thought Alice ‘without pictures or conversations?’ So she was considering in her own mind (as well as she could, for the hot day made her feel very sleepy and stupid), whether the pleasure of making a daisy-chain would be worth the trouble of getting up and picking the daisies, when suddenly a White Rabbit with pink eyes ran close by her. 5.2.3 Tags with attributes Some tags need to do more than just demarcate some text. An &lt;a&gt; (for “anchor”) tag is used to create a hyperlink. It’s not enough to just wrap &lt;a&gt;...&lt;/a&gt; around the link’s text, as you also need to specify where the hyperlink points to. Start tags let you include attributes that customize the appearance or behavior of the tag. In this case, we’ll add an href attribute to our &lt;a&gt; start tag: &lt;p&gt;Learn more about &lt;strong&gt;Shiny&lt;/strong&gt; at &lt;a href=&quot;https://shiny.rstudio.com&quot;&gt;this website&lt;/a&gt;.&lt;/p&gt; Learn more about Shiny at this website. There are dozens of attributes that all tags accept, and hundreds of attributes that are specific to particular tags. You don’t have to worry about memorizing them all–even full-time web developers don’t do that. There are two attributes that are used constantly, though. The id attribute uniquely identifies a tag in a document. That is, no two tags in a single document should share the same id value, and each tag can have zero or one id value. As far as the web browser is concerned, the id attribute is completely optional and has no intrinsic effect on the appearance or behavior of the rendered tag. However, it’s incredibly useful for identifying a tag for special treatment by CSS or JavaScript, and as such, plays a crucial role for Shiny apps. The class attribute provides a way of classifying tags in a document. Unlike id, any number of tags can have the same class, and each tag can have multiple classes (space separated). Again, classes don’t have an intrinsic effect, but are hugely helpful for using CSS or JavaScript to target groups of tags. In the following example, we’ve given a &lt;p&gt; tag an id and two classes: &lt;p id=&quot;storage-low-message&quot; class=&quot;message warning&quot;&gt;Storage space is running low!&lt;/p&gt; Storage space is running low! Here, the id and class values have had no discernible effect. But we could, for example, write CSS that any elements with the message class should appear at the top of the page, and that any elements with the warning class should have a yellow background and bold text; and we could write JavaScript that automatically dismisses the message if the storage situation improves. 5.2.4 Parents and children In the example above, we have a &lt;p&gt; tag that contains some text that contains &lt;strong&gt; and &lt;a&gt; tag.s We can refer to &lt;p&gt; as the parent of &lt;strong&gt;/&lt;a&gt;, and &lt;strong&gt;/&lt;a&gt; as the children of &lt;p&gt;. And naturally, &lt;strong&gt; and &lt;a&gt; are called siblings. It’s often helpful to think of tags and text as forming a tree structure: &lt;p&gt; ├── &quot;Learn more about&quot; ├── &lt;strong&gt; │ └── &quot;Shiny&quot; ├── &quot;at&quot; ├── &lt;a href=&quot;...&quot;&gt; │ └── &quot;this website&quot; └── &quot;.&quot; 5.2.5 Comments Just as you can use the # character to comment out a line of R code, HTML lets you comment out parts of your web page. Use &lt;!-- to start a comment, and --&gt; to end one. Anything between these delimiters will be ignored during the rendering of the web page, although it will still be visible to anyone who looks at your raw HTML by using the browser’s View Source command. &lt;p&gt;This HTML will be seen.&lt;/p&gt; &lt;!-- &lt;p&gt;This HTML will not.&lt;/p&gt; --&gt; &lt;!-- &lt;p&gt; Nor will this. &lt;/p&gt; --&gt; This HTML will be seen. 5.2.6 Escaping Any markup language like HTML, where there are characters that have special meaning, needs to provide a way to “escape” those special characters–that is, to insert a special character into the document without invoking its special meaning. For example, the &lt; character in HTML has a special meaning, as it indicates the start of a tag. What if you actually want to insert a &lt; character into the rendered document–or, let’s say, an entire &lt;p&gt; tag? &lt;p&gt;In HTML, you start paragraphs with &quot;&lt;p&gt;&quot; and end them with &quot;&lt;/p&gt;&quot;.&lt;/p&gt; In HTML, you start paragraphs with \"\" and end them with \"\". That doesn’t look as we intended at all! The browser has no way of knowing that we meant the outer &lt;p&gt; and &lt;/p&gt; to be interpreted as markup, and the inner &lt;p&gt; and &lt;/p&gt; to be interpreted as text. Instead, we need to escape the inner tags so they become text. The escaped version of &lt; is &amp;lt;, and &gt; is &amp;gt;. &lt;p&gt;In HTML, you start paragraphs with &quot;&amp;lt;p&amp;gt;&quot; and end them with &quot;&amp;lt;/p&amp;gt;&quot;.&lt;/p&gt; In HTML, you start paragraphs with \"&lt;p&gt;\" and end them with \"&lt;/p&gt;\". (Yes, escaped characters look pretty ugly. That’s just how it is.) Each escaped character in HTML starts with &amp; and ends with ;. There are lots of valid sequences of characters that go between, but besides lt (less than) and gt (greater than), the only one you’re likely to need to know is amp; &amp;amp; is how you insert a &amp; character into HTML. Escaping &lt;, &gt;, and &amp; is mandatory if you don’t want them interpreted as special characters; other characters can be expressed as escape sequences, but it’s generally not necessary. Escaping &lt;, &gt;, and &amp; is so common and crucial that every web framework contains a function for doing it (in our case it’s htmltools::htmlEscape), but as we’ll see in a moment, Shiny will usually do this for you automatically. 5.2.7 HTML tag vocabulary That concludes our whirlwind tour of HTML syntax. This is all you’ll need to know to follow the discussion on the pages that follow. The much larger part of learning HTML is getting to know the actual tags that are available to you, what attributes they offer, and how they work with each other. Fortunately, there are scores of excellent, free HTML tutorials and references online; Mozilla’s Introduction to HTML is one example. 5.3 Generating HTML with tag objects With this background knowledge in place, we can now talk about how to write HTML using R. To do this, we’ll use the htmltools package. The htmltools package started life as a handful of functions in Shiny itself, and was later spun off as a standalone package when its usefulness for other packages–like rmarkdown and htmlwidgets–became evident. In htmltools, we create the same trees of parent tags and child tags/text as in raw HTML, but we do so using R function calls instead of angle brackets. For example, this HTML from an earlier example: &lt;p id=&quot;storage-low-message&quot; class=&quot;message warning&quot;&gt;Storage space is running low!&lt;/p&gt; would look like this in R: library(htmltools) p(id=&quot;storage-low-message&quot;, class=&quot;message warning&quot;, &quot;Storage space is running low!&quot;) Storage space is running low! This function call returns a tag object; when printed at the console, it displays its raw HTML code, and when included in Shiny UI, its HTML becomes part of the user interface. Look carefully and you’ll notice: The &lt;p&gt; tag has become a p() function call, and the end tag is gone. Instead, the end of the &lt;p&gt; tag is indicated by the function call’s closing parenthesis. The id and class attributes have become named arguments to p(). The text contained within &lt;p&gt;...&lt;/p&gt; has become a string that is passed as an unnamed argument to p(). Let’s break down each of these bullets further. 5.3.1 Using functions to create tags The htmltools package exports the p function for the &lt;p&gt; tag, but because there are scores of valid HTML tags, it doesn’t export a function for each one. Only the most common HTML tags have a function directly exposed in the htmltools namespace: &lt;p&gt;, &lt;h1&gt; through &lt;h6&gt;, &lt;a&gt;, &lt;br&gt;, &lt;div&gt;, &lt;span&gt;, &lt;pre&gt;, &lt;code&gt;, &lt;img&gt;, &lt;strong&gt;, &lt;em&gt;, and &lt;hr&gt;. When writing these tags, you can simply use the tag name as the function name, e.g. div() or pre(). To write all other tags, prefix the tag name with tags$. For example, to create a &lt;ul&gt; tag, there’s no dedicated ul() function, but you can call tags$ul(). The tags object is a named list that htmltools provides, and it comes preloaded with almost all of the valid tags in the HTML5 standard. When writing a lot of HTML from R, you may find it tiresome to keep writing tags$. If so, you can use the withTags function to wrap an R expression, wherein you can omit the tags$ prefix. In the following code, we call ul() and li(), whereas these would normally be tags$ul() and tags$li(). withTags( ul( li(&quot;Item one&quot;), li(&quot;Item two&quot;) ) ) Item one Item two Finally, in some relatively obscure cases, you may find that not even tags supports the tag you have in mind; this may be because the tag is newly added to HTML and has not been incorporated into htmltools yet, or because it’s a tag that isn’t defined in HTML per se but is still understood by browsers (e.g. the &lt;circle&gt; tag from SVG). In these cases, you can fall back to the tag() (singular) function and pass it any tag name. tag(&quot;circle&quot;, list(cx=&quot;10&quot;, cy=&quot;10&quot;, r=&quot;20&quot;, stroke=&quot;blue&quot;, fill=&quot;white&quot;)) (Notice that the tag() function alone needs its attribute and children wrapped in a separate list() object. This is a historical quirk, don’t read into it.) 5.3.2 Using named arguments to create attributes When calling a tag function, any named arguments become HTML attributes. # From https://getbootstrap.com/docs/3.4/javascript/#collapse a(class=&quot;btn btn-primary&quot;, `data-toggle`=&quot;collapse&quot;, href=&quot;#collapseExample&quot;, &quot;Link with href&quot; ) ## &lt;a class=&quot;btn btn-primary&quot; data-toggle=&quot;collapse&quot; href=&quot;#collapseExample&quot;&gt;Link with href&lt;/a&gt; The preceding example includes some attributes with hyphens in their names. Be sure to quote such names using backticks, or single or double quotes. Quoting is also permitted, but not required, for simple alphanumeric names. Generally, HTML attribute values should be single-element character vectors, as in the above example. Other simple vector types like integers and logicals will be passed to as.character(). Another valid attribute value is NA. This means that the attribute should be included, but without an attribute value at all: tags$input(type = &quot;checkbox&quot;, checked = NA) ## &lt;input type=&quot;checkbox&quot; checked/&gt; You can also use NULL as an attribute value, which means the attribute should be ignored (as if the attribute wasn’t included at all). This is helpful for conditionally including attributes. is_checked &lt;- FALSE tags$input(type = &quot;checkbox&quot;, checked = if (is_checked) NA) ## &lt;input type=&quot;checkbox&quot;/&gt; 5.3.3 Using unnamed arguments to create children Tag functions interpret unnamed arguments as children. Like regular HTML tags, each tag object can have zero, one, or more children; and each child can be one of several types of objects: 5.3.3.1 Tag objects Tag objects can contain other tag objects. Trees of tag objects can be nested as deeply as you like. div( p( strong( a(href=&quot;https://example.com&quot;, &quot;A link&quot;) ) ) ) A link 5.3.3.2 Plain text Tag objects can contain plain text, in the form of single-element character vectors. p(&quot;I like turtles.&quot;) I like turtles. Note that character vectors of longer length are not supported. Use the paste function to collapse such vectors to a single element. str(LETTERS) ## chr [1:26] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; ... div(paste(LETTERS, collapse = &quot;, &quot;)) A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z One important characteristic of plain text is that htmltools assumes you want to treat all characters as plain text, including characters that have special meaning in HTML like &lt; and &gt;. As such, any special characters will be automatically escaped: div(&quot;The &lt;strong&gt; tag is used to create bold text.&quot;) The &lt;strong&gt; tag is used to create bold text. 5.3.3.3 Verbatim HTML Sometimes, you may have a string that should be interpreted as HTML; similar to plain text, except that special characters like &lt; and &gt; should retain their special meaning and be treated as markup. You can tell htmltools that these strings should be used verbatim (not escaped) by wrapping them with HTML(): html_string &lt;- &quot;I just &lt;em&gt;love&lt;/em&gt; writing HTML!&quot; div(HTML(html_string)) I just love writing HTML! Warning: Be very careful when using the HTML() function! If the string you pass to it comes from an untrusted source, either directly or indirectly, it could compromise the security of your Shiny app via an extremely common type of security vulnerability known as Cross-Site Scripting (XSS). For example, you may ask a user of your app to provide their name, store that value in a database, and later display that name to a different user of your app. If the name is wrapped in HTML(), then the first user could provide a fragment of malicious HTML code in place of their name, which would then be served by Shiny to the second user. While I’m not aware of any such attacks having ever happened with a Shiny app, similar attacks have been carried out against companies as tech-savvy as Facebook, eBay, and Microsoft. It is safe to use HTML() if your Shiny app will only ever be run locally for a single user (not deployed on a server for multiple users), or if you are absolutely sure you know where the HTML string came from and that its contents are safe. 5.3.3.4 Lists While each call to a tag function can have as many unnamed arguments as you want, you can also pack multiple children into a single argument by using a list(). The following two code snippets will generate identical results: tags$ul( tags$li(&quot;A&quot;), tags$li(&quot;B&quot;), tags$li(&quot;C&quot;) ) A B C tags$ul( list( tags$li(&quot;A&quot;), tags$li(&quot;B&quot;), tags$li(&quot;C&quot;) ) ) A B C It can sometimes be handy to use a list when generating tag function calls programmatically. The snippet below uses lapply to simplify the previous example: tags$ul( lapply(LETTERS[1:3], tags$li) ) A B C 5.3.3.5 NULL You can use NULL as a tag child. NULL children are similar to NULL attributes; they’re simply ignored, and are only supported to make conditional child items easier to express. In this example, we use show_beta_warning to decide whether or not to show a warning; if not, the result of the if clause will be NULL. show_beta_warning &lt;- FALSE div( h3(&quot;Welcome to my Shiny app!&quot;), if (show_beta_warning) { div(class = &quot;alert alert-warning&quot;, role = &quot;alert&quot;, &quot;Warning: This app is in beta; some features may not work!&quot; ) } ) Welcome to my Shiny app! 5.3.3.6 Mix and match Tag functions can be called with any number of unnamed arguments, and different types of children can be used within a single call. div( &quot;Text!&quot;, strong(&quot;Tags!&quot;), HTML(&quot;Verbatim &lt;span&gt;HTML!&lt;/span&gt;&quot;), NULL, list( &quot;Lists!&quot; ) ) Text! Tags! Verbatim HTML! Lists! 5.4 Customizing with CSS In the previous section, we talked about HTML, the markup language that specifies the structure and content of the page. Now we’ll talk about Cascading Style Sheets (CSS), the language that specifies the visual style and layout of the page. Similar to our treatment of HTML, we’ll give you an extremely superficial introduction to CSS—just enough to be able to parse the syntax visually, not enough to write your own. Then we’ll talk about the mechanisms available in Shiny for adding your own CSS. 5.4.1 Introduction to CSS As we saw in the previous sections, we use HTML to create a tree of tags and text. CSS lets us specify directives that control how that tree is rendered; each directive is called a rule. Here’s some example CSS that includes two rules: one that causes all &lt;h3&gt; tags (level 3 headings) to turn red and italic, and one that hides all &lt;div class=&quot;alert&quot;&gt; tags in the &lt;footer&gt;: h3 { color: red; font-style: italic; } footer div.alert { display: none; } The part of the rule that precedes the opening curly brace is the selector; in this case, h3. The selector indicates which tags this rule applies to. The parts of the rule inside the curly braces are properties. This particular rule has two properties, each of which is terminated by a semicolon. 5.4.1.1 CSS selectors The particular selector we used in these cases (h3 and footer div.alert) are very simple, but selectors can be quite complex. You can select tags that match a specific id or class, select tags based on their parents, select tags based on whether they have sibling tags. You can combine such critieria together using “and”, “or”, and “not” semantics. Here are some extremely common selector patterns: .foo - All tags whose class attributes include foo div.foo - All &lt;div&gt; tags whose class attributes include foo #bar - The tag whose id is bar div#content p:not(#intro) - All &lt;p&gt; tags inside the &lt;div&gt; whose id is content, except the &lt;p&gt; tag whose id is intro A full introduction to CSS selectors is outside the scope of this chapter, but if you’re interested in learning more, the Mozilla tutorial on CSS selectors is a good place to start. 5.4.1.2 CSS properties The syntax of CSS properties is very simple and intuitive. What’s challenging about CSS properties is that there are so darn many of them. There are dozens upon dozens of properties that control typography, margin and padding, word wrapping and hyphenation, sizing and positioning, borders and shadows, scrolling and overflow, animation and 3D transforms… the list goes on and on. Here are some examples of common properties: font-family: Open Sans, Helvetica, sans-serif; Display text using the Open Sans typeface, if it’s available; if not, fall back first to Helvetica, and then to the browser’s default sans serif font. font-size: 14pt; Set the font size to 14 point. width: 100%; height: 400px; Set the width to 100% of the tag’s container, and the height to a fixed 400 pixels. max-width: 800px; Don’t let the tag grow beyond 800 pixels wide. Most of the effort in mastering CSS is in knowing what properties are available to you, and understanding when and how to use them. Again, the rest of this large topic is outside of our scope, but you can learn more from Mozilla’s CSS resources page. 5.4.2 Including custom CSS in Shiny Shiny gives you several options for adding custom CSS into your apps. Which method you choose will depend on the amount and complexity of your CSS. 5.4.2.1 Inline style tag with tags$style If you have one or two very simple rules, the easiest way to add CSS is by inserting a &lt;style&gt; tag, using tags$style(). This can go almost anywhere in your UI. library(shiny) ## ## Attaching package: &#39;shiny&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## knit_print.shiny.tag ui &lt;- fluidPage( tags$style(HTML(&quot; body, pre { font-size: 18pt; } &quot;)) ) The HTML() is only strictly necessary if your CSS code includes special characters like &lt;, &gt;, or &amp;; those characters will be escaped by default, which will lead to invalid CSS. I like to add it as a matter of habit, though you should heed the warning about untrusted input in Section 5.3.3.3. 5.4.2.2 Standalone CSS file with includeCSS The second method is to write a standalone .css file, and use the includeCSS function to add it to your UI. If you’re writing more than a couple of lines of CSS, this gives you the benefit of being able to use a text editor that knows how to interpret CSS. Most text editors, including RStudio IDE, will be able to provide syntax highlighting and autocompletion when editing .css files. For example, if you have a custom.css file sitting next to your app.R, you can do something like this: ui &lt;- fluidPage( includeCSS(&quot;custom.css&quot;), ... # the rest of your UI ) The includeCSS call will return a &lt;style&gt; tag, whose body is the content of custom.css. If you wish for this CSS to be hoisted into the page’s &lt;head&gt; tag, you can call tags$head(includeCSS(&quot;custom.css&quot;)), though in practice it doesn’t make a lot of difference either way. 5.4.2.3 Standalone CSS file with &lt;link&gt; tag Perhaps you have a large amount of CSS in a standalone .css file, and you don’t want it to be inserted directly into the HTML page, as includeCSS does. You can also choose to serve up the .css file at a separate URL, and link to it from your UI. To do this, create a www subdirectory in your application directory (the same directory that contains app.R) and put your CSS file there—for example, www/custom.css. Then add the following line to your UI: tags$head(tags$link(rel=&quot;stylesheet&quot;, type=&quot;text/css&quot;, href=&quot;custom.css&quot;)) (Note that the href attribute should not include www; Shiny makes the contents of the www directory available at the root URL path.) This approach makes sense for CSS that is intended for a specific Shiny app. If you are writing CSS for a reusable component, especially one in an R package, keep reading to learn about HTML dependencies. 5.5 Managing JavaScript/CSS dependencies One of the best things about working with HTML is the absolutely mindboggling number of open source JavaScript and/or CSS libraries that you can incorporate into your pages. Such libraries can be as simple as a few dozen styling rules in a single .css file, or as complex as 670KB of minified JavaScript for visualizing spatial data using WebGL. Whether simple or complex, the first step in using any JavaScript/CSS library is referencing its .js and/or .css files from your HTML. Any well-documented library will have a “Getting Started” section that includes a snippet of HTML, including &lt;script&gt; and/or &lt;link&gt; tags, that need to be pasted into the special &lt;head&gt; section of the webpage. This puts the onus on the webpage author to know about all the JavaScript/CSS dependencies that are used by any element of the page. For traditional web developers, that’s totally normal. But for Shiny (and R Markdown, and htmlwidgets), we wanted to free R users from having to think very much about JavaScript/CSS dependencies at all. For example, the sliderInput that comes with Shiny happens to be implemented using a JavaScript library called ionRangeSlider. With the traditional approach, if you wanted to add a sliderInput to your Shiny app, you’d also have to make a separate declaration somewhere in your UI to load the .js and .css files for ionRangeSlider. And you’d have to make sure that you only make that declaration once per page, lest you accidentally load a library twice, which can cause some libraries to stop working. For Shiny, we wanted instead to have R users simply call sliderInput(), and let us sort out the necessary dependencies automatically. In fact, we want R users to be able to combine whatever UI objects they want, and just not think about dependencies at all. To make this possible, we created a first-class object for HTML dependencies. An HTML dependency object is a description of a single JavaScript/CSS library. As a Shiny app author, you generally don’t create these directly. Instead, these objects are created by package authors who want to make reusable UI functions that depend on external JavaScript/CSS—like sliderInput(). If you’re such a package author, you absolutely should be using HTML dependency objects rather than calling tags$link(), tags$script(), or includeCSS directly. 5.5.1 Creating HTML dependency objects To form such an object, you call htmlDependency with the following arguments: name: The name of the library. version: The version number of the library. (If two or more HTML dependency objects are found with the same name but different version numbers, only the one with the latest version number will be loaded.) src: A single location where the library’s resources (JavaScript, CSS, and/or images) can be found. This is usually an absolute filesystem path, but can also be a web URL. For resources that are bundled into an R package, you can provide a relative filesystem path (relative to the installed package directory, i.e. system.file(package=&quot;pkgname&quot;)) if you provide an additional package argument. script: Relative paths to JavaScript files that should be loaded. stylesheet: Relative paths to CSS files that should be loaded. Here’s an example from the leaflet.mapboxgl package: mapbox_gl_dependency &lt;- htmlDependency( &quot;mapbox-gl&quot;, &quot;0.53.1&quot;, src = &quot;node_modules/mapbox-gl/dist&quot;, package = &quot;leaflet.mapboxgl&quot;, script = &quot;mapbox-gl.js&quot;, stylesheet = &quot;mapbox-gl.css&quot;, all_files = FALSE ) In this example, the leaflet.mapboxgl package has a node_modules/mapbox-gl/dist subdirectory that contains two files: mapbox-gl.js and mapbox-gl.css. For this particular library, we could also have pointed to these hosted URLs: https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.1/mapbox-gl.js https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.1/mapbox-gl.css We can do this by passing src=c(href=&quot;https://api.tiles.mapbox.com/mapbox-gl-js/v0.53.1/&quot;) and removing the package argument. However, be aware that a small but significant number of Shiny users do so from networks that are disconnected from the wider Internet for security reasons, and for those users, this dependency would fail to load. 5.5.2 Using HTML dependency objects Once you’ve created an HTML dependency object, using it is straightforward. If you have a function that returns a tag object, have that function return a tag object and dependency instead, using a tagList. create_mapbox_map &lt;- function(map_id) { tagList( div(id = map_id), mapbox_gl_dependency ) } You can bundle any number of dependencies with your HTML this way; just add additional dependency arguments to the tagList. TODO: Exercises? "],
["reactivity-mental-model.html", "Chapter 6 Understanding reactive programming 6.1 Introduction 6.2 Introducing reactive programming 6.3 The building blocks of reactive programming 6.4 An example: CRAN download logs 6.5 Demystifying dependency tracking 6.6 A step-by-step tour of reactive execution", " Chapter 6 Understanding reactive programming 6.1 Introduction In this chapter, we’ll form a mental model of reactive programming. Without reactive programming, Shiny would not exist, and in well-informed hands it is by far the most elegant, robust, and productive way we know of for creating dynamic user interfaces. The biggest drawback of reactive programming is that it is not intuitive–at first. Even experienced R users can have trouble getting their heads around reactive programming as they get started with Shiny, and those with deep experience in software engineering may feel uncomfortable with a programming paradigm with so much “magic”. But once you’ve formed an accurate mental model, you’ll see that reactive programming is built on simple concepts and mechanisms that you can easily reason about. Terminology note Before we go further, please be aware that the term “reactive programming” is a fairly general term in the programming world. While all reactive programming libraries/frameworks/languages are broadly about writing programs that respond to changing values, they vary enormously in their terminology, designs, and implementations. In this book, whenever we refer to “reactive programming”, we are referring specifically to reactive programming as implemented in Shiny. Conversely, if you read any material about reactive programming that isn’t specifically about Shiny, it’s unlikely that those concepts or even terminology will be relevant to writing Shiny apps. For readers who do have some experience with other reactive programming frameworks, our approach is similar to Meteor and MobX, and very different than the ReactiveX family or anything that labels itself Functional Reactive Programming. Outline Section 6.2 discusses the motivation behind reactive programming, and the mental shift that’s required to practice it successfully. Section 6.3 explains the three main building blocks of reactive programming: reactive values, reactive expressions and observers/outputs. Section 6.4 demonstrates reactive programming in action by refactoring a real-world R script into a reactive application. Section 6.5 reveals the (anticlimactically simple) mechanism that Shiny uses to determine the dependency/dependent relationships between reactive objects. Section 6.6 walks step-by-step through the execution of a reactive app, via many diagrams. 6.2 Introducing reactive programming Reactive programming is primarily a style of programming that emphasizes values that change over time, and calculations and actions that depend on those values. In one sense, all programmers are used to “values that change over time”: they’re called “variables”, right? Yes, variables in R represent values and they can change over time. But they’re not particularly designed to help you when their values change. temp_celsius &lt;- 10 is_freezing &lt;- temp_celsius &lt;= 0 print(is_freezing) #&gt; [1] FALSE So far so good–the temp_celsius variable has the value 10, and the is_freezing variable has the value TRUE. But once we change temp_celsius: temp_celsius &lt;- -3 print(is_freezing) #&gt; [1] FALSE temp_celsius has changed, but unless you take special action, any derived variables like is_freezing remain unchanged and are now out of date. Reactive programming is a way of structuring your R code so that relationships between changing values (like temp_celsius) and the derived expressions that rely on them (like is_freezing) can be automatically detected and maintained. To put it concretely, Shiny apps are interactive: users change input controls (sliders, textboxes, checkboxes), which causes logic to run on the server (reading CSVs or performing database queries, subsetting data, running simulations or models), ultimately resulting in outputs updating (plots, tables, blocks of text, downloadable PDFs). For Shiny apps to be useful, all of the relevant server logic needs to run, and any affected outputs need to update. Otherwise, the user will looking at incorrect information. Conversely, for Shiny apps to respond quickly to user input, it’s important that only the relevant logic runs, and only the affected outputs update. It’d be a frustratingly poor user experience if, say, changing a plot y-axis from linear to log scale caused the expensive logic behind a totally unrelated summary table to be rerun. 6.2.1 The traditional approach: Event-driven programming In decades past, there wouldn’t even be a question about how such interactive user interfaces would be written: event-driven programming was the only game in town. It’s an appealingly simple paradigm: you register callback functions to be executed in response to events (e.g. a mouse click, or a textbox’s value being changed). Had Shiny been invented five years earlier, your server.R code might have looked like this: function(input, output, session) { updatePlot &lt;- function() { xvar &lt;- input$xvar$value yvar &lt;- input$yvar$value p &lt;- ggplot(data, aes_string(xvar, yvar)) + geom_point() output$plot &lt;- p } input$xvar$onChange(function() { updatePlot() }) input$yvar$onChange(function() { updatePlot() }) } Quite simple, right? The updatePlot function creates a plot using the values from input$xvar and input$yvar, and uses that plot to update output$plot. And then you tell Shiny to execute updatePlot() whenever either of those inputs changes. In that alternate universe, my life would be a lot easier, as this chapter would be a lot shorter–there’d be a lot less to explain. Unfortunately, it would make life a lot worse for Shiny app authors. This kind of user interface programming is simple, but not easy! As your application adds more features, it becomes very difficult to keep track of what inputs affect what calculations, and what calculations affect each other, and what input and calculations affect what outputs and actions. Before long, you start to trade off correctness (just update everything whenever anything changes) against performance (try to update only the necessary parts, and pray you didn’t miss any edge cases), because it’s so difficult to optimize for both. Reactive programming roared into the programming mainstream in the 2010s, via the blisteringly fast-paced world of JavaScript UI frameworks. Pioneering frameworks like Knockout, Ember, and (my personal inspiration) Meteor demonstrated that reactive programming could make UI programming dramatically easier. Within a few short years, reactive programming has come to dominate UI programming on the web, with hugely popular frameworks like React, Vue.js, and Angular that are either inherently reactive or designed to work with reactive backends. Shiny has demonstrated that reactive programming is a particularly good fit for apps that transform and/or visualize complex data. These kinds of apps seem to naturally decompose into discrete steps, like loading data, subsetting, aggregating, predicting, etc. These steps can be individually expressed using reactive objects, which can then be managed by Shiny. 6.3 The building blocks of reactive programming While there are lots of reactive programming related functions in Shiny, there are three objects that almost all of them build on, both conceptually and literally. We call these reactive primitives because they are a fundamental part of the reactive framework and, unlike many of the other reactive objects that we’ll eventually cover, could not possibly be implemented outside of the framework itself. These reactive primitives are: Reactive values Reactive expressions Observers We’ll go through these one by one, though not in that order; instead, we’ll start by talking about reactive values, jump ahead to observers, then finish up with reactive expressions. 6.3.1 Reactive values: values that change over time Before we start talking about reactive values, one pedagogically awkward little wrinkle is that reactive values come in three different flavors: inputs, reactiveValues, and reactiveVal. For this chapter’s purposes, these three types are conceptually identical, so we’ll mostly stick to discussing inputs. Inputs are by far the most common type of reactive value. Anyone who’s written a single Shiny app has seen the input object, which is provided as an argument to your Shiny app’s server function. It represents the collective input received from your app’s user interface, and you access individual input values from it with the same operators you’d use for a named list, e.g. input$x or input[[&quot;x&quot;]] for an input named x. The values in input change whenever something happens in the user interface. Because input is intended to be a reflection of the state of the user interface, you can read from it but you can’t write to it (at least not directly, see chapter TODO). If you attempt input$x &lt;- 20, you’ll get an error. Don’t be fooled, though: while input$x looks like reading a normal value from a normal list, there’s something very important going on under the hood. In order to understand what that is, we need to talk about who is doing the reading. Generally, R functions and variables are totally agnostic to, and in fact ignorant of, who/what is calling or reading them. When an R function is invoked, it runs and returns a value. When a variable is read, it doesn’t matter to the variable why that read is happening. In reactive programming, the situation is very different. If a read of a regular variable is asking “What’s the value of x?”, reading a reactive value is asking “What’s the value of input$x? And also notify me the next time input$x changes, please!” In other words, a reactive read has implications for both now (returns the current value) and later (notifies of the next change to the value). Because reactive reads have this additional “later” effect, the input object is very selective about who is allowed to access its data. Attempting to read input$x from anywhere but a bona fide reactive object, like a reactive expression or observer, throws an error. The actual text of this error is “Operation not allowed without an active reactive context”, and it essentially means “I won’t talk to you unless you give me a way to notify you that input$x changed”. Now let’s shift gears and talk about the objects that can read reactive values, and what will happen when they’re notified of changes in input$x. There are two fundamental types of reactive readers (also known as consumers) in Shiny. One type is for actions (with side effects), the other is for calculations (no side effects). 6.3.2 Observers: Actions that execute automatically Observers are one type of reactive consumer. An observer takes a code block that performs an action of some kind. Here’s an observer that prints the value of x every time it changes: observe({ message(&quot;We&#39;re about to print x:&quot;) print(input$x) }) This code block does three things: Prints out the message &quot;We're about to print x:&quot; Prints the value of input$x Subscribes to be notified of the next change to input$x (this subscription happens automatically, just by reading input$x) When input$x changes, and this observer is notified, it requests that the Shiny runtime run its code block again, and the three steps above will repeat. Note that it’s not just the single line print(input$x) that re-runs, but the entire code block. The unit of granularity for reactivity, in this case, is the whole observer rather than any particular line of code. Observers are reactive consumers because they know how to respond to the fact that one of their dependencies changed: they re-run their code block. Observers aren’t limited to reading a single reactive value; each observer can read zero, one, or multiple reactive values. observe({ message(&quot;We&#39;re about to print x:&quot;) print(input$x) message(&quot;And also y:&quot;) print(input$y) }) This observer’s entire code block will re-execute when either input$x or input$y change; it doesn’t wait until both have changed. 6.3.3 Reactive expressions: Smart calculations Reactive expressions are the other fundamental type of reactive consumer. While observers model actions that have side effects, reactive expressions model calculations that don’t have side effects. (There’s nothing that prevents you from putting side effects in your reactive expressions, but it’s generally a bad idea.) Here’s a very simple reactive expression named up_to_x that generates a sequence of numbers based on input$x. (If you’re not familiar with seq_len, it simply returns a sequence of increasing numbers starting from 1 to whatever number you pass it; for example, seq_len(3) returns c(1L, 2L, 3L).) up_to_x &lt;- reactive({ seq_len(input$x) }) The mere act of creating this reactive expression doesn’t cause any code to execute. Rather, it just means that this sequence of numbers is available for retrieval, by calling up_to_x() like it’s a function. In this sense, creating a reactive expression is like to declaring an R function: nothing actually happens until you call it. In the following snippet, the code contained in up_to_x (from the above snippet) is not executed until the line print(up_to_x()) is reached, as this is the first time the result of up_to_x is actually requested. (Because of this property, we say that reactive expressions are lazy as opposed to eager.) observe({ print(up_to_x()) }) This observer prints the sequence to the console whenever up_to_x changes (i.e. whenever input$x changes, because up_to_x reads input$x). Just like with reading reactive values, reactive expressions are only readable by reactivity-aware consumers, and for the same reason: because up_to_x() is more than just “Can you calculate the current value of up_to_x?”; instead, it’s “Can you calculate the current value of up_to_x? And also notify me if something about this sequence changes?” So far we’ve learned that reactive expressions are reactive: they know when the reactive values they’ve read have changed, and they alert their readers when their own value may have changed. They’re also lazy: they contain code, but that code doesn’t execute unless/until someone tries to actually retrieve the value of the reactive expression (by calling it like a function). The final important property of reactive expressions is that they cache their most recent value. If you’re not familiar with the term “cache”, it means keeping a previously retrieved (or in this case, calculated) result in hand so that it can be used to satisfy future requests. The first time a reactive expression is called, it will execute its code body, and depending on what that code does, it might take a significant amount of time. But when the calculation is complete, the resulting value will be both returned to the caller and remembered by the reactive expression. Subsequent calls to the reactive expression take essentially no time at all, as the saved value can be returned instantly. If a reactive expression depends on reactive values or expressions, then any changes to those will cause the cached value to be discarded. When that happens, the next call to the reactive expression will again cause an actual calculation, whose result will then be saved for subsequent calls. These particular properties–laziness, caching, reactivity, and lack of side effects–combine to give us an elegant and versatile building block for reactive programming. 6.3.3.1 Reactive graphs Reactive expressions are unique among reactive primitives, in that they are the only construct that can be both read other objects (i.e. act as a consumer), and be read from (i.e. act as a source). Observers can read/consume values, but they cannot offer a value to anyone directly. Reactive values can be read, but since they are essentially just named values, they have no notion of reading anything else. If the reactive world was limited to reactive values and observers, you could line up all the reactive values in one column and all the observers in a second column, and then draw many-to-many relationships between the two columns. Because reactive expressions can act as both source and consumer, you can have reactive expressions that read from/depend on other reactive expressions, and those reactive expressions can read from/depend on still other reactive expressions, and so on. So reactive expressions don’t just introduce an additional flat list of connection points between values and observers, but rather, allow us to build arbitrarily deeply layered graphs of reactive objects, with values on the left edges and observers on the right edges, and networks of reactive expressions in between. These intermediate networks aren’t strictly necessary for reactive programming, and in fact, many JavaScript reactive UI frameworks make do with only reactive values and observers. But for our purposes, reactive expressions and the intermediate networks they enable are a huge boon to both organizing our application logic and keeping our applications responsive. 6.3.4 Outputs You may wonder how Shiny outputs fit into this picture. By outputs, I’m referring to code like this: output$text &lt;- renderText({ paste(up_to_x(), collapse = &quot;, &quot;) }) You’ve seen that outputs can successfully read reactive values (like inputs) and reactive expressions. So are they reactive expressions? Or are they observers? The answer is neither, per se. Reactive expressions and observers (and reactive values) are primitives of reactive programming, meaning, they are fundamental building blocks. Outputs, on the other hand, are a feature of Shiny that is built on top of those reactive primitives. The details of how they are implemented are not that important, but it is important to know their characteristics. Most importantly, outputs are reactive consumers. Output code is allowed to read reactive values like input$x or reactive expressions like up_to_x(), and the output will know when those reactive dependencies change. Whereas observers execute eagerly and reactive expressions execute lazily, outputs are somewhere in between. When an output’s corresponding UI element is visible in the browser, outputs execute eagerly; that is, once at startup, and once anytime their relevant inputs or reactive expressions change. However, if their UI element becomes hidden (e.g. it is located on a tabPanel that is not active, or removeUI is called to actively remove it from the page) then Shiny will automatically suspend (pause) that output from reactively executing. (In rare cases, you may prefer to process even outputs that aren’t hidden. You can use the outputOptions() function’s suspendWhenHidden to opt out of the automatic suspension feature on an output-by-output basis.) We also know that observers should be used for side effects (actions), and reactive expressions for their return values (calculations). Again, outputs are somewhere in between. Depending on the renderXXX function you use to wrap it, your render code block may need to return a value and/or perform a side effect. For example, renderText expects you to return a string, while renderPrint expects you to make calls to print(); and renderPlot expects you to either draw a plot to the active graphics device or return a plottable object (like a ggplot2 object). Though outputs allow (and may even require) side effects, this doesn’t mean you should include just any side effects in your output code. Shiny assumes that the whole code block of an output exists only in service of populating that output. If your output code block contains logic whose side effects are important for reasons apart from the actual output, you should extract that logic into a separate observer. That way, you can be confident it will execute regardless of whether the output is visible or not, now or in the future. 6.4 An example: CRAN download logs Now let’s walk through an example of an ordinary R script for downloading, aggregating, and visualizing some data. This script downloads and parses the download logs for a specific date. The logs are in compressed CSV format and contain one row per download; on 2019-02-20, the number of rows was 3,437,899. The columns are: date time size (in bytes) r_version, the version of R, binary packages only r_arch, the machine architecture (e.g. &quot;x86_64&quot; or &quot;i386&quot;), binary packages only r_os, the operating system, binary packages only package, the package being requested version, the exact version of the package being requested country ip_id, an anonymized identifier for the IP address of the requestor After downloading the data, the script will tally the number of rows (downloads) with each value in a specified column. For example, if we specify the package column, then we get the number of times each package was downloaded; if we specify the r_os column, we get the number of downloads from each operating system. Once the tallying is done, we’ll plot this data in a couple of ways. We’ll zoom in on the top few most popular values (e.g. the most popular packages), and we’ll also visualize all the values to get a sense of the “long tail”, to show how quickly the downloads decrease as we move down the list of packages. Now, on to the code. First, we’ll load the libraries we need. library(lubridate) #&gt; #&gt; Attaching package: &#39;lubridate&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; date library(readr) #&gt; #&gt; Attaching package: &#39;readr&#39; #&gt; The following object is masked _by_ &#39;.GlobalEnv&#39;: #&gt; #&gt; read_csv library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:lubridate&#39;: #&gt; #&gt; intersect, setdiff, union #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union library(ggplot2) #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang library(gt) Next, we’ll introduce configuration variables that can be modified to look at different dates or tally by different dimensions, or to change the number of top values to focus on. (Not to look too far ahead, but these are values we might eventually want to turn into interactive inputs.) # A. Configuration variables date &lt;- &quot;2019-02-20&quot; dimension &lt;- &quot;package&quot; # r_version, r_arch, r_os, package, country, ip_id top_count &lt;- 20L Now we begin the real work of the script. Downloading and parsing the data will be by far the most time-consuming portions, and we’ll use readr::read_csv to accomplish both in one step. ## Downloading and parsing ========= # B. Form URL for downloading url &lt;- sprintf(&quot;http://cran-logs.rstudio.com/%s/%s.csv.gz&quot;, year(date), date) # C. Download/parse data download_data &lt;- read_csv(url) #&gt; Classes &#39;spec_tbl_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 3437899 obs. of 10 variables: #&gt; $ date : Date, format: &quot;2019-02-20&quot; &quot;2019-02-20&quot; ... #&gt; $ time : &#39;hms&#39; num 21:14:59 21:14:50 21:13:56 21:14:54 ... #&gt; ..- attr(*, &quot;units&quot;)= chr &quot;secs&quot; #&gt; $ size : num 81906 509106 183218 946922 327237 ... #&gt; $ r_version: chr &quot;3.5.2&quot; &quot;3.4.3&quot; &quot;3.5.2&quot; &quot;3.5.2&quot; ... #&gt; $ r_arch : chr &quot;x86_64&quot; &quot;x86_64&quot; &quot;x86_64&quot; &quot;x86_64&quot; ... #&gt; $ r_os : chr &quot;darwin15.6.0&quot; &quot;darwin15.6.0&quot; &quot;linux-gnu&quot; &quot;darwin15.6.0&quot; ... #&gt; $ package : chr &quot;acepack&quot; &quot;BEST&quot; &quot;munsell&quot; &quot;plyr&quot; ... #&gt; $ version : chr &quot;1.4.1&quot; &quot;0.5.1&quot; &quot;0.5.0&quot; &quot;1.8.4&quot; ... #&gt; $ country : chr &quot;HU&quot; NA &quot;IT&quot; &quot;US&quot; ... #&gt; $ ip_id : num 1 2 3 4 1 5 5 6 7 8 ... Now that the data is in memory, we will perform the data manipulation. The implementation details here are not that important; just understand that we’re taking the download_data data frame from above, with its 3.4 million rows, and turning it into counts of rows grouped by the dimension in question (package). ## Data manipulation ========= # D. Count observations, grouping by the desired dimension by_frequency &lt;- download_data %&gt;% pull(dimension) %&gt;% table() %&gt;% sort(decreasing = TRUE) %&gt;% as_tibble() %&gt;% setNames(c(dimension, &quot;downloads&quot;)) # E. Limit to the top `top_count` most_frequent &lt;- by_frequency %&gt;% head(top_count) Here’s the resulting by_frequency data frame. most_frequent is identical, but limited to the top 20 rows. #&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 20 obs. of 2 variables: #&gt; $ package : chr &quot;Rcpp&quot; &quot;rlang&quot; &quot;dplyr&quot; &quot;tibble&quot; ... #&gt; $ downloads: int 44164 39830 32637 32042 30607 29487 28783 27588 27317 27059 ... Now we’re ready to plot our data; one bar plot using most_frequent, and one line plot using the full by_frequency. ## Various outputs ========= # F. Plot the top values ggplot(most_frequent, aes_string(x = dimension)) + geom_bar(aes(y = downloads / 1000), stat = &quot;identity&quot;) + ylab(&quot;Downloads (thousands)&quot;) + coord_flip() + scale_x_discrete(limits = rev(most_frequent[[dimension]])) + ggtitle(paste0(&quot;CRAN download counts by &quot;, dimension)) # G. Plot all of the counts, by rank (&quot;long tail&quot;) ggplot(by_frequency, aes(x = seq_along(downloads), y = downloads)) + geom_line() + xlab(&quot;Rank&quot;) + scale_y_log10() + ggtitle(paste0(&quot;CRAN download counts by &quot;, dimension, &quot; rank&quot;)) You can see the entire script at [TODO: LINK]. To transform this code into a Shiny app, we need to answer a few questions: 6.4.1 1. What are the inputs for the user to provide? Fortunately, our script gathered all the configurable variables at the top: date, dimension, top_count. The only work for us to do here is to use dateInput, selectInput, and numericInput, respectively, in the UI section of our app, and then change references to these variables in the server function to input$date, input$dimension, and input$top_count. 6.4.2 2. What are the conceptual “steps” performed in the script? You can already tell by the code comments above that I’ve divided the work into discrete steps. Incidentally, this is good practice anyway, as is breaking larger scripts into smaller functions (which I did not do in this case). Whatever form of subdivision you use, breaking down the problem into smaller subproblems makes our code easier to write, read, and debug. I’ve summarized these steps in the table below. Step Variable Description A date, dimension, top_count Configuration variables B url Form URL for downloading C download_df Download/parse data D by_frequency Count observations, grouping by the desired dimension E most_frequent Limit to the top top_count F Plot the top values G Plot all of the counts This is the breakdown I’m using, but there isn’t one single correct arrangement of steps; you may consider steps B and C to really be a single step, or for step D to be composed of multiple steps (e.g. for summarizing, sorting, and converting to a tibble to all be individual steps). These changes wouldn’t cause any noticeable change in the readability of our code or the performance of our app. But just because there isn’t a single right answer, does not mean there are no wrong answers! We’ll discuss some of the factors we want to consider in a section below. [TODO: xref] 6.4.3 3. For each of the steps performed: is it a calculation, an output, or a task? To answer this question, ask yourself two questions: Does this step return a value? And if so, is the return value the only reason this task would ever be useful? If the answer to both of these questions is “yes”, then you have a calculation. For example, in step C, we download and parse the data in one step. Yes, there is a return value–it’s the data frame. And yes, the only reason you would call read_csv(url) is because you want the data frame. Note that it might be a different story if we performed the download in a separate download.file(url, destfile) step; in that case, downloading the data to a known location might be a useful end, in and of itself. In that case, the downloading could be considered a separate task. On the other side, step F–plotting the top values–is an output. Once we’ve categorized each step, we go through the fairly mechanical process of turning each calculation into a reactive expression, and each task into an observer or output. For example, steps B and C are changed from this: # B. Form URL for downloading url &lt;- sprintf(&quot;http://cran-logs.rstudio.com/%s/%s.csv.gz&quot;, year(input$date), input$date) # C. Download/parse data download_data &lt;- read_csv(url) To this: # B. Form URL for downloading url &lt;- reactive({ sprintf(&quot;http://cran-logs.rstudio.com/%s/%s.csv.gz&quot;, year(input$date), input$date) }) # C. Download/parse data download_data &lt;- reactive({ read_csv(url()) }) Rather than assigning the value of sprintf(...) to url, we create a reactive expression using reactive(). And when the download_data reactive expression wants to access the URL, it uses url() instead of url. For each output, you need to take the additional step of deciding the type of the output (e.g. plot, table, or text) and choosing the output/render function pair that corresponds to that type (plotOutput/renderPlot, tableOutput/renderTable, verbatimTextOutput/renderPrint). Our step F goes from this: # F. Plot the top values ggplot(most_frequent, aes_string(x = dimension)) + geom_bar(aes(y = downloads / 1000), stat = &quot;identity&quot;) + ylab(&quot;Downloads (thousands)&quot;) + coord_flip() + scale_x_discrete(limits = rev(most_frequent[[dimension]])) + ggtitle(paste0(&quot;CRAN download counts by &quot;, dimension)) To this: # F. Plot the top values output$plot_top_values &lt;- renderPlot({ ggplot(most_frequent(), aes_string(x = dimension)) + geom_bar(aes(y = downloads / 1000), stat = &quot;identity&quot;) + ylab(&quot;Downloads (thousands)&quot;) + coord_flip() + scale_x_discrete(limits = rev(most_frequent()[[dimension]])) + ggtitle(paste0(&quot;CRAN download counts by &quot;, dimension)) }) 6.5 Demystifying dependency tracking With traditional object-oriented UI programming, an inordinate amount of effort and complexity comes from explicitly managing the relationships between different pieces of UI, and cascading sets of variables that depend on the UI and on each other. We want our code to be fast, correct, and easy to write/maintain. But when creating complex interactive data displays using traditional techniques, we’re lucky to achieve even two out of those three. (TODO: This would be more powerful with illustrative examples.) In contrast, with just reactive inputs/values, reactive expressions, and observers/outputs, we have a rich vocabulary for expressing calculations and outputs, and that forms the foundation for a better way to do UI programming. As long as we can break up our logic into distinct-but-related calculations, actions, and outputs, Shiny’s reactive framework will automatically handle the tedious and error-prone task of deciding what pieces need to be updated, and when. Shiny is designed to let you get started writing apps without fully understanding how reactive programming works; you generally wrap conventional looking R code in reactive({...}) or renderXXX({...}), and everything “just works”. This contributes to the initial impression that Shiny is “magic”, which thrills beginners but triggers immediate skepticism in expert programmers. Software feels magical when the user is unable to form a mental model for how it works; the greater the gap between what the software does and the user’s ability to explain it does it, the more magical the software feels. Unfortunately, magic in software usually leads to disillusionment. Without a solid mental model to reason with, it’s extremely difficult to predict how the software will act when you venture beyond the borders of its demos and examples. And when things don’t go the way you expect, debugging is almost impossible. (TODO: Examples of bad magic??) But sometimes there is good magic in software. As Tom Dale said of his Ember.js JavaScript framework: “We do a lot of magic, but it’s good magic, which means it decomposes into sane primitives.” This is the quality we aspire to for Shiny, especially when it comes to reactive programming. When you peel back the layers of reactive programming, you won’t find a pile of heuristics, special cases, and hacks; but rather, a clever but ultimately fairly straightforward mechanism for automatic dependency tracking, that will–I hope!–cease to feel like magic at all. 6.5.1 How dependency tracking works The most striking aspect of reactive programming in Shiny is that a reactive expression, observer, or output “knows” which reactive values/inputs and reactive expressions it depends on. For example: output$plot &lt;- renderPlot({ plot(head(cars, input$rows)) }) When people are first exposed to Shiny code like this, the most common question is, “How does Shiny know that output$plot reads input$rows?” And the most common guess is that Shiny parses the body of the renderPlot code block, looking for symbols that seem to be relevant for reactivity, the same way a human being would. If that strikes you as a fragile approach, I agree. Even a change as simple as giving input a new name would break things: output$plot &lt;- renderPlot({ x &lt;- input plot(head(cars, x$rows)) }) So, no, that’s not the way Shiny works. If that approach could be called “static analysis”, what Shiny actually does might be called “dynamic instrumentation”. 6.5.1.1 Reactive contexts Before the plot output begins executing, it creates an object that’s internal to Shiny called a reactive context. (As an app author, you’ll never create or see one of these objects directly.) The reactive context doesn’t represent the plot output as a whole, but just a single execution of the output. If, over the life of a Shiny session, the plot is (re)rendered a dozen times, then a dozen reactive contexts will have been created. The Shiny package has a top-level variable (like a global variable, but one only visible to code inside the Shiny package) that is always pointing to the “current” or “active” reactive context. The plot output assigns its new context to this variable, then executes its code block, then restores the previous value of the variable. Basically like this code sketch (for illustrative purposes only): # Create the new context ctx &lt;- ReactiveContext$new() # Set as the current context (but save the prev context) prev_ctx &lt;- shiny:::currentContext shiny:::currentContext &lt;- ctx # Actually run user code here renderPlot({ ... }) # Restore the prev context shiny:::currentContext &lt;- prev_ctx The purpose of the context object is to provide a rendezvous point between the reactive consumer object that is executing, and the reactive values and expressions that are being read. There are two important methods on context objects: invalidate() - Informs the context that a value or expression that it read, is now potentially out of date (invalidated); and so whatever reactive consumer object owns this context should also be considered out of date. onInvalidated(func) - Asks the context to invoke the given callback function in the future, if and when invalidate() is called. 6.5.1.2 Intercepting reads If you’ve read carefully so far, you may be able to see where this is going. While a reactive consumer object (reactive expression, observer, or output) is executing, it creates a context object and puts it in a globally accessible variable, making it possible for any other code to invalidate that context at any point in the future. Reactive values and expressions use this context object to connect the dots between reactive dependencies. When a reactive source is read–using either input$x or up_to_date()–not only is the appropriate value returned, but a side effect also silently occurs. Each reactive value or expression maintains a list of contexts that depend on its current value being up-to-date; each read of the reactive value or expression causes the current context object to be added to that list. Each time a reactive value is modified, or a reactive expression is invalidated, it calls invalidate() on each dependent context. This invalidates the corresponding reactive consumer objects. In summary, the way Shiny “magically” establishes the connections between dependency and dependant really comes to these two simple mechanisms: each reactive consumer creates a context object and installs it in a global location during execution, and each reactive source augments every read operation with a grabbing of the context object and saving it for later invalidation. There is no way that Shiny can accidentally overlook a reactive dependency relationship, or establish one erroneously (though there are a few ways to instruct Shiny to intentionally overlook reactive dependencies, as we’ll see later). 6.6 A step-by-step tour of reactive execution Here’s an illustrated version of a reactive graph. In the diagram above, the shapes on the left are reactive inputs and values, the ones in the middle are reactive expressions, and on the right are observers and outputs. (For the rest of this discussion, we’ll simply refer to outputs as observers, rather than saying “observers and/or outputs” every time.) The lines between the shapes are directional, with the arrows indicating the direction of reactivity–we’ll see in a moment why this means the arrows go from left to right, instead of from right to left. Now we’ll follow along, step by step, as a Shiny app is loaded and these reactive relationships are discovered, formed, destroyed, and reformed. 6.6.1 A session begins When a reactive app is visited and a session begins, the server function is executed and the reactive objects are created. However, Shiny has no a priori knowledge of the relationships (lines) between the objects. As you can see in the following diagram, the shapes are all present but there are no lines yet. Note that all of the reactive expressions and observers are a darker color. This indicates that they are in invalidated state, which is the initial state for these objects. When an observer is in this state, it means it needs to be executed as soon as Shiny has a chance to. When a reactive expression is in this state, it means that the next time that reactive expression is read, its code will need to be executed (i.e., no result value is currently cached for that reactive expression). 6.6.2 Execution begins Now that the session has been initialized, we can begin the execution phase. In this phase, Shiny picks an observer (not a reactive expression) and starts executing it. In the diagrams below, we use a green fill to indicate when a node is actively executing. (You may wonder how Shiny decides which of the several invalidated observers/outputs to execute. The short answer is that you should act as if it’s random. Ideally, your observers and especially outputs won’t care what order they execute in, as each will function independently from the others. However, if you do have observers whose side effects must always happen in a certain relative order, you can use the observe function’s priority argument to dictate that order for observers. You can also control the priority of outputs by calling the outputOptions() function with a priority argument.) 6.6.3 Reading a reactive expression During an observer’s execution, it may read one or more reactive expressions. As soon as this occurs, a dependency/dependent relationship is established between the reactive expression and the observer, represented below by the arrow. The arrow points from left to right; this is the direction that reactivity will flow, as we’ll see in a moment. As we said, all reactive expressions start out in invalidated state (represented by the grey fill), including the one this observer is now trying to access. So in order to return a value, the reactive expression needs to execute its code, which it starts doing now. We fill the reactive expression with green to represent that it’s running. Note that the observer is still green: just because the reactive expression is now running, doesn’t mean that the observer has finished. The observer is waiting on the reactive expression to return its value so its own execution can continue, just like a regular function call in R. 6.6.4 Reading an input This particular reactive expression happens to read a reactive input. Again, a dependency/dependent relationship is established, so we add another arrow. Unlike reactive expressions and observers, reactive inputs have nothing to execute, since they simply represent a variable. So the input doesn’t turn green, we just immediately get its current value. 6.6.5 Reactive expression completes In our example, the reactive expression reads another reactive expression, which in turn reads another input. We’ll skip over the blow-by-blow description of those steps, since they’re just a repeat of what we’ve already described. When the reactive expression has completed executing, it saves (caches) the resulting value internally before returning it to the observer that requested it. Now that the reactive expression has finished executing, it’s no longer in invalidated (grey) or running (green) state; rather, it’s in idle (white) state. When a reactive expression reaches this state, it means it’s up-to-date and will not re-execute its code even if other reactive expressions or observers request its value. Instead, it can instantly return the value it cached during its most recent execution. 6.6.6 Observer completes Now that the reactive expression has returned its value to the observer, the observer can complete executing its code. When this has completed, it too enters the idle state, so we change its fill color to white. 6.6.7 The next observer executes Now that Shiny has completed execution of the first observer, it chooses a second one to execute. Again, it turns green, and may read values from invalidated reactive expressions, which will turn green, and so on. This cycle will repeat until every invalidated observer enters the idle (white) state. 6.6.8 Execution completes, outputs flushed At last, all of the observers have finished execution and are now idle. This round of reactive execution is complete, and nothing will happen with this session until some external force acts on the system (e.g. the user of the Shiny app moving a slider in the user interface). In reactive terms, this session is now at rest. I didn’t mention it before, but when Shiny outputs finish executing, they don’t immediately update the output in the browser. Instead, all of the new outputs are held until this point, at which time they are “flushed” to the browser all at once. (It’d be nice if Shiny could let the app author decide whether outputs update one by one or all at once, but as of this writing, Shiny only supports the latter.) Let’s stop here for just a moment and think about what we’ve done. We’ve read some inputs, calculated some values, and generated some outputs. But more importantly, in the course of doing that work, we also discovered the relationships between these different calculations and outputs. An arrow from a reactive input to a reactive expression tells us that if the reactive input’s value changes, the reactive expression’s result value can no longer be considered valid. And an arrow from a reactive expression to an output means that if the reactive expression’s result is no longer valid, then the output’s previous result needs to be refreshed. Just as important: we also know which nodes are not dependent on each other. If no path exists from a particular reactive input to a particular output (always traveling in the direction that the arrows are pointing), then a change to that input couldn’t possibly have an effect on that output. That gives us the ability to state with confidence that we don’t need to refresh that output when that input changes, which is great–the less work we need to do, the sooner we can get results back to the user. 6.6.9 An input changes The previous step left off with our Shiny session in a fully idle state. Now imagine that the user of the application changes the value of a slider. This causes the browser to send a message to their server, instructing Shiny to update the corresponding reactive input. When a reactive input or value is modified, it kicks off an invalidation phase, which we haven’t seen up to this point. The invalidation phase starts at the changed input/value, which we’ll fill with grey, our usual color for invalidation. 6.6.10 Notifying dependents Now, we follow the arrows that we drew earlier. Each reactive expression and observer that we come across is put into invalidated state, then we continue following the arrows out of that node. As a refresher, for observers, the invalidated state means “should be executed as soon as Shiny gets a chance”, and for reactive expressions, it means “must execute the next time its value is requested”. In this diagram, the arrows in the lighter shade indicate the paths we took from the changed reactive input through the reactive graph. Note that we can only traverse the arrows in their indicated direction; it’s impossible to move from a reactive expression leftwards to a reactive input, for example. 6.6.11 Removing relationships Next, each invalidated reactive expression and observer “erases” all of the arrows coming in or out of it. You can think of each arrow as a one-shot notification that will fire the next time a value changes. Not every time, just the next time. So all of the arrows coming out of a reactive expression are safe to erase; like a used bottle rocket, they’ve fired their one shot. (Less obvious is why we erase the arrows coming in to an invalidated node, even if the node they’re coming from isn’t invalidated. While those arrows represent notifications that haven’t yet fired, the invalidated node no longer cares about them. The only reason nodes care about notifications is so they can be invalidated; well, that invalidation has already happened due to some other dependency.) It may seem perverse that we put so much value on those relationships, and now we’re going out of our way to erase them! But the truth is, though these particular arrows were important, they are now themselves out of date. The only way to ensure that our graph stays accurate is to erase arrows when they become stale, and let Shiny rediscover the relationships around these nodes as they reexecute. This marks the end of the invalidation phase. 6.6.12 Reexecution Now we’re in a pretty similar situation to when the Shiny session first started; we have some invalidated reactive expressions and outputs, and we don’t have any arrows coming in or out of them. It’s time to do exactly what we did then: execute the invalidated outputs/observers, one at a time. What’s different this time, though, is that not all of the reactive expressions and outputs are starting out in the invalidated state. Some parts of the graph weren’t affected–neither directly nor indirectly–by the reactive input that had changed. That’s great, as we won’t need to reexecute those parts of the graph, even if they are used again by some of the invalidated parts! "]
]
